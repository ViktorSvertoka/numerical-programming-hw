# -*- coding: utf-8 -*-
"""hw_06_svertoka_viktor.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1S4x3wTML2ixZhV6UT8A9tkgT5gD2WOFj
"""

import os
import librosa
import librosa.display
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.cluster import SpectralClustering
from sklearn.preprocessing import StandardScaler
from urllib.request import urlretrieve
from IPython.display import Audio
import zipfile

# Завантаження та розархівування датасету
url = "https://github.com/karoldvl/ESC-50/archive/master.zip"
zip_file_path = "ESC-50-master.zip"
download_path = "./ESC-50-master/"
if not os.path.exists(download_path):
    urlretrieve(url, zip_file_path)
    with zipfile.ZipFile(zip_file_path, 'r') as zip_ref:
        zip_ref.extractall("./")
    os.remove(zip_file_path)

# Перевірка структури після розархівування
!ls -R ./ESC-50-master/

# Завантаження мета-інформації
metadata_path = './ESC-50-master/meta/esc50.csv'
df = pd.read_csv(metadata_path)

# Вибірка звуків із мітками 'dog' та 'chirping_birds'
selected_labels = ['dog', 'chirping_birds']
filtered_df = df[df['category'].isin(selected_labels)].reset_index(drop=True)

# Функція для побудови спектрограми
def generate_spectrogram(file_path, n_fft=2048, hop_length=512):
    y, sr = librosa.load(file_path, sr=None)
    spectrogram = np.abs(librosa.stft(y, n_fft=n_fft, hop_length=hop_length))
    return spectrogram, sr

# Функція для зменшення розміру спектрограми (пулінг)
def pooling(spectrogram, pool_size=(2, 2)):
    pooled = spectrogram[:len(spectrogram) // pool_size[0] * pool_size[0], :len(spectrogram[0]) // pool_size[1] * pool_size[1]]
    return pooled.reshape(pooled.shape[0] // pool_size[0], pool_size[0], -1, pool_size[1]).mean(axis=(1, 3))

# Обробка обраних звуків
spectrograms = []
labels = []
for _, row in filtered_df.iterrows():
    file_path = os.path.join(download_path, "audio", row['filename'])
    spectrogram, sr = generate_spectrogram(file_path)
    pooled_spectrogram = pooling(spectrogram)
    flattened_spectrogram = pooled_spectrogram.flatten()
    spectrograms.append(flattened_spectrogram)
    labels.append(row['category'])

# Масштабування ознак
scaler = StandardScaler()
scaled_data = scaler.fit_transform(spectrograms)

# Кластеризація за допомогою SpectralClustering
n_clusters = len(selected_labels)
clustering = SpectralClustering(n_clusters=n_clusters, affinity='nearest_neighbors', random_state=42)
cluster_labels = clustering.fit_predict(scaled_data)

# Аналіз кластерів
filtered_df['cluster'] = cluster_labels

# Візуалізація спектрограм перших кількох звуків із кожного кластеру
for cluster_id in range(n_clusters):
    cluster_subset = filtered_df[filtered_df['cluster'] == cluster_id]
    print(f"Кластер {cluster_id}: {cluster_subset['category'].unique()}")
    for _, row in cluster_subset.head(2).iterrows():
        file_path = os.path.join(download_path, "audio", row['filename'])
        y, sr = librosa.load(file_path, sr=None)
        plt.figure(figsize=(10, 4))
        librosa.display.specshow(librosa.amplitude_to_db(np.abs(librosa.stft(y)), ref=np.max), sr=sr, x_axis='time', y_axis='log')
        plt.colorbar(format='%+2.0f dB')
        plt.title(f"{row['category']} - Кластер {cluster_id}")
        plt.show()

# Висновки
print("Висновки:")
print("1. Звуки із різних категорій ('dog', 'chirping_birds') здебільшого потрапляють у різні кластери.")
print("2. Перетворення Фур'є дозволяє ефективно вилучати частотні ознаки, які добре підходять для кластеризації.")
print("3. Пулінг зменшує розмірність спектрограм, що прискорює обчислення без втрати ключової інформації.")